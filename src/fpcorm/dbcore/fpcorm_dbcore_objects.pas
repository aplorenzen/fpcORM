unit fpcorm_dbcore_objects;

{< @abstract(This unit contains all the super types, derived into the types
     written in the code generated by fpcORM.)
   @author(Andreas Lorenzen - aplorenzen@gmail.com)
   @created(2014-06-24)

   The classes in this unit, are intended to provide all the basic functionality
   for the final types that are genererated by the fpcORM. Types representing
   the database table and table fields are here, with functions that supplies
   all the fundamental functionality, of maintaining the state of the derived
   objects. }

{$mode objfpc}{$H+}

interface

uses
  Classes,
  SysUtils,
  SyncObjs,
  SQLDB,
  FGL,

  fpcorm_common_interfaces,
  fpcorm_common_types,

  fpcorm_dbcore_utils,
  fpcorm_dbcore_constants,

    dateutils;

type
  { forward declaration of interfaces }
  //IfoDBObject = interface;
  //IfoDBTable = interface;
  //IfoDBTableField = interface;
  //
  //{ forward declaration of classes }
  TfoDBTableObject = class;
  { Cannot fowrward declare specialized generic types!? }
  { TfoDBTableObjectList = class; }

  TfoDBTableFieldByte = class;
  TfoDBTableFieldShortInt = class;
  TfoDBTableFieldSmallInt = class;
  TfoDBTableFieldWord = class;
  TfoDBTableFieldLongInt = class;
  TfoDBTableFieldLongWord = class;
  TfoDBTableFieldInt64 = class;
  TfoDBTableFieldQWord = class;
  TfoDBTableFieldBoolean = class;
  TfoDBTableFieldSingle = class;
  TfoDBTableFieldDouble = class;
  TfoDBTableFieldExtended = class;
  TfoDBTableFieldCurrency = class;
  TfoDBTableFieldString = class;
  TfoDBTableFieldDateTime = class;

  //TfoDBObjectStatus = class;
  //TfoDBTableInformation = class;
  //{ seems that one cannot make forward declaration of generic or specialized types? }
  //{ TfoDBTableField = class; }
  //{ TfoDBTableFieldList = class; }
  //
  //TfoDBAbstractTableField = class;


  { This type represents a field in a table, a specific field in a specific row,
    but without it's value at this abstract level. All the other properties of
    the field are implemented at this level though. }

  TfoDBAbstractTableField = class(TfoObserverSubject)
  private
    fOwnerTable: TfoDBTableObject;
    fFieldName: String;
    fIsNull: Boolean;
    fIsChanged: Boolean;
    fIsIndexed: Boolean;
    fIsPrimaryKey: Boolean;
    fIsForeignKey: Boolean;
    fHasDefault: Boolean;
    fIsNullable: Boolean;
    { TODO -APL -cDBTypes 5: The field metadata should also be contained here, and created when the
      decendant is instanciated, or perhaps be an option }

    procedure SetIsNull(aIsNull: Boolean);
    procedure SetIsChanged(aIsChanged: Boolean);
  protected
    { Internal function, that removes any value in decending classes, eg. int = 0, string = '' }
    procedure ClearValue; virtual; abstract;
  public
    constructor Create(aOwnerTable: TfoDBTableObject; aFieldName: String = '');
    destructor Destroy; override;

    function ToSql(): String; virtual; abstract;
    function ToXML(): String; virtual; abstract;
    function AsString(): String; virtual; abstract;
    procedure CopyValue(aTableField: TfoDBAbstractTableField); virtual; abstract;

    property OwnerTable: TfoDBTableObject read fOwnerTable;
    property FieldName: String read fFieldName write fFieldName;
    property IsNull: Boolean read fIsNull write SetIsNull;
    property IsChanged: Boolean read fIsChanged write SetIsChanged;
    property IsPrimaryKey: Boolean read fIsPrimaryKey write fIsPrimaryKey;
    property IsIndexed: Boolean read fIsIndexed write fIsIndexed;
    property IsForeignKey: Boolean read fIsForeignKey write fIsForeignKey;
    property HasDefault: Boolean read fHasDefault write fHasDefault;
    property IsNullable: Boolean read fIsNullable write fIsNullable;
  end;

  { This list type, is a specialization of a generic pointer list, by the
    TfoDBAbstractTableField type. Essentially this list type can contain a range
    of abstract database table fields, without access to their actual local
    values. However, the values a can be accessed in the ToSql, ToXML and
    AsString functions, in the TfoDBAbstractTableField, for passing it to the
    database, an XML document or to a GUI as a String f.ex. }

  TfoDBTableFieldList = specialize TFPGList<TfoDBAbstractTableField>;

  //{ IfoDBObject }
  //IfoDBObject = interface(IInterface)
  //  ['{3BCDE6E8-2406-4FE1-9584-E16DD5B7496E}']
  //  function GetConnection(): TSQLConnector;
  //  procedure SetConnection(aConnection: TSQLConnector);
  //end;
  //
  //IfoDBTable = interface(IfoDBObject)
  //  ['{57363BA5-AF19-42FE-A7F6-3C52096D24C0}']
  //  function GetTableInformation(): TfoDBTableInformation;
  //  procedure SetTableInformation(aTableInformation: TfoDBTableInformation);
  //end;
  //
  //IfoDBTableField = interface(IInterface)
  //  ['{C1C665A2-6F77-418B-B4A0-50B4F9B65239}']
  //  function GetFieldName: String;
  //  procedure SetFieldName(aFieldName: String);
  //  function GetIsNull: Boolean;
  //  procedure SetIsNull(aIsNull: Boolean);
  //  function GetIsAssigned: Boolean;
  //  procedure SetIsAssigned(aIsAssigned: Boolean);
  //  function GetIsChanged: Boolean;
  //  procedure SetIsChanged(aIsChanged: Boolean);
  //  function GetIsIndexed: Boolean;
  //  procedure SetIsIndexed(aIsIndexed: Boolean);
  //  function GetIsForeignKey: Boolean;
  //  procedure SetIsForeignKey(aIsForeignKey: Boolean);
  //  function GetIsPrimaryKey: Boolean;
  //  procedure SetIsPrimaryKey(aIsPrimaryKey: Boolean);
  //  function GetHasDefault: Boolean;
  //  procedure SetHasDefault(aHasDefault: Boolean);
  //  function GetOwnerTable: TfoDBTableObject;
  //  procedure SetOwnerTable(AOwnerTable: TfoDBTableObject);
  //  function ToSql(): String;
  //  function ToXML(): String;
  //  function AsString(): String;
  //end;


  { TODO -oAPL -cDBTypes 2: Clean up the TfoDBObjectStatus object - no need for
    all those messy setters and getters I think? }

  { The TfoDBTableStatus class, is the holder of the state of a single table row
    object. A TfoDBTableObject object, has an instance of this type inside of it, to
    track it's status. One particular reason for not putting all of the fields
    in this type, directly into the TfoDBTableObject type, is that when the TfoDBTableObject
    type is decended from, into a type representing a specific table in a
    specific database - with all of the autogenerated fields and their names,
    there could very well be conflifts between the names of the fields in this
    type, and in the generated subclass. That can be handled of course, and will
    be handled in the subclass fieldnaming logic, but it would mean that some
    fields will have one name in the database, and another in the generated
    type. Which is unwanted. }

  { TfoDBTableStatus }

  TfoDBTableStatus = class(TInterfacedPersistent)
  private
    fOwnerTable: TfoDBTableObject;
    fIsNew: Boolean;
    fIsLoaded: Boolean;
    fIsChanged: Boolean;
    fIsDeleted: Boolean;

    fCreatedTime: TDateTime;
    fLoadedTime: TDateTime;
    fChangedTime: TDateTime;
    fSavedTime: TDateTime;
    fDeletedTime: TDateTime;

    procedure SetIsNew(aIsNew: Boolean);
    procedure SetIsLoaded(aIsLoaded: Boolean);
    procedure SetIsChanged(aIsChanged: Boolean);
    procedure SetIsDeleted(aIsDeleted: Boolean);
  public
    constructor Create(aOwnerTable: TfoDBTableObject);
    destructor Destroy; override;

    property OwnerTable: TfoDBTableObject read fOwnerTable;
    property IsNew: Boolean read fIsNew write SetIsNew;
    property IsLoaded: Boolean read fIsLoaded write SetIsLoaded;
    property IsChanged: Boolean read fIsChanged write SetIsChanged;
    property IsDeleted: Boolean read fIsDeleted write SetIsDeleted;
    property CreatedTime: TDateTime read fCreatedTime write fCreatedTime;
    property LoadedTime: TDateTime read fLoadedTime write fLoadedTime;
    property ChangedTime: TDateTime read fChangedTime write fChangedTime;
    property SavedTime: TDateTime read fSavedTime write fSavedTime;
    property DeletedTime: TDateTime read fDeletedTime write fDeletedTime;
  end;

  { TfoDBTableInformation }

  TfoDBTableInformation = class(TInterfacedPersistent)
  private
    fTableCatalog: String;
    fTableSchema: String;
    fTableName: String;
    fTableType: String;
    { TODO -oAPL -cDBTypes 4: TfoDBTableInformation: More fields here, steal from dORM, list of PK items and FK items, indexed things and more }
  public
    constructor Create;
    destructor Destroy; override;
    { TODO -oAPL -cDBTypes 2: TfoDBTableInformation: Implement getters, setters and properties here }
  end;

  { TfoDBTableField }

  generic TfoDBTableField<T> = class(TfoDBAbstractTableField)
  private
    fValue: T;

    procedure SetValue(aValue: T);
  protected
    procedure ClearValue; override;
  public
    constructor Create(aOwnerTable: TfoDBTableObject; aFieldName: String = '');
    destructor Destroy; override;
    procedure CopyValue(aTableField: TfoDBAbstractTableField); override;

    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;

    property Value: T read fValue write SetValue;
  end;

  { The TfoDBTableObject object, represents a database table... more info here }

  TfoDBTableObject = class(TfoObserver)
  private
    fConnection: TSQLConnector;
    fMutex: TCriticalSection;

    fTableInformation: TfoDBTableInformation;
    fObjectStatus: TfoDBTableStatus;

    fFieldList: TfoDBTableFieldList;
    fIsDestroying: Boolean;

    fOpenedConnection: Boolean;

    // TfoDBTableList
  protected
    { The OpenConnection function provides the trivial means of opening the
      database connection to the decendant types. @return(True if the connection
      was opened successfully, False if connection could not be established.) }
    function OpenConnection: Boolean;
    { The CloseConnection function closes the local connection. Only if it is
      actually open and if the decending object also was the initiator of the
      connection. Making this distinction allows decendants to use the
      CloseConnection function anywhere in decendant types, where they may want
      to close the database connection, and only close it if that decendant
      object instance was the object that opened it. @return(False if
      unsuccessful and True if closed successfully). @param(aConsumeException
      indicates to the function, if any exception caused should be silenced, or
      re-raised to the caller.) }
    function CloseConnection(aConsumeException: Boolean = False): Boolean;
  public
    constructor Create(aConnection: TSQLConnector; aMutex: TCriticalSection);
    destructor Destroy; override;

    { AddTableField is intended to be called from the constructors of the fields
      that are owned by the decending object from this class. Upon creation, a
      new field (decending from TfoDBAbstractTableField) is passed it's owning table as a constructor parameter. The
      field should in turn then call it's owner's AddTableField procedure, to
      add itself to it's table's field collection. So that the table object has
      a complete list of all the fields that are contained in it. }
    procedure AddTableField(aTableField: TfoDBAbstractTableField);

    function Load_OpenSQL(aSQL: String): Boolean; virtual; abstract;
    procedure ReceiveSubjectUpdate(aSubject: IfoObserverSubject); override;

    // function LoadBy_PK_REC_ID(AREC_ID: Integer; AOwnerInfo: TTableItem = nil): Boolean;
    // function InsertAsNew(): Boolean;
    function Insert: Boolean;

    // the LoadedOrNotNew function may not be nessecary, it was used to 'probe' if an instance was loaded, when using lazyloading
    // function LoadedOrNotNew(AFreeIfNot: Boolean = True): Boolean;
    property Connection: TSQLConnector read fConnection write fConnection;
    property TableInformation: TfoDBTableInformation read fTableInformation write fTableInformation;
    property Mutex: TCriticalSection read fMutex write fMutex;
    property ObjectStatus: TfoDBTableStatus read fObjectStatus write fObjectStatus;
    property FieldList: TfoDBTableFieldList read fFieldList write fFieldList;
    property IsDestroying: Boolean read fIsDestroying write fIsDestroying;
    property OpenedConnection: Boolean read fOpenedConnection;
  end;

  { The TfoDBTableObjectList type, is used for holding a generic list of all the
    foreign key referenced objects that are referenced with a foreign key field
    from this table object }
  TfoDBTableObjectList = specialize TFPGList<TfoDBTableObject>;

  { The TfoDBTableObjectListList type, is a local list of all the objects that
    are referencing this table object with a foreign key in their own table,
    that points to the PK in this table. Each of the TfoDBTableObjectLists in
    this list, represent a table that references this table with a foreign key }
  TfoDBTableObjectListList = specialize TFPGList<TfoDBTableObjectList>;

  // integer types
  // http://www.freepascal.org/docs-html/ref/refsu5.html#x27-260003.1.1

  // Type	      Range	                                        Size in bytes
  // Byte	      0 .. 255	                                    1
  // Shortint	 -128 .. 127	                                  1
  // Smallint	 -32768 .. 32767	                              2
  // Word	      0 .. 65535	                                  2
  // Integer	 either smallint or longint	                    size 2 or 4
  // Cardinal	 longword	                                      4
  // Longint	 -2147483648 .. 2147483647	                    4
  // Longword	  0 .. 4294967295	                              4
  // Int64	    -9223372036854775808 .. 9223372036854775807	  8
  // QWord	    0 .. 18446744073709551615	                    8


  { TfoDBTableFieldByte }

  TfoDBTableFieldByte = class(specialize TfoDBTableField<Byte>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
    procedure CopyValue(aTableField: TfoDBAbstractTableField); override;
    //function ValueEquals(aTableField: TfoDBTableFieldByte): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldShortInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSmallInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldInt64): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldQWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldBoolean): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSingle): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDouble): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldExtended): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldCurrency): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldString): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDateTime): Boolean; overload;
  end;

  { TfoDBTableFieldShortInt }

  TfoDBTableFieldShortInt = class(specialize TfoDBTableField<ShortInt>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
    //procedure CopyValue(aTableField: TfoDBAbstractTableField); override;
    //function ValueEquals(aTableField: TfoDBTableFieldByte): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldShortInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSmallInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldInt64): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldQWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldBoolean): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSingle): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDouble): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldExtended): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldCurrency): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldString): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDateTime): Boolean; overload;
  end;

  { TfoDBTableFieldSmallInt }

  TfoDBTableFieldSmallInt = class(specialize TfoDBTableField<SmallInt>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
    //procedure CopyValue(aTableField: TfoDBAbstractTableField); override;
    //function ValueEquals(aTableField: TfoDBTableFieldByte): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldShortInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSmallInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldInt64): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldQWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldBoolean): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSingle): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDouble): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldExtended): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldCurrency): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldString): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDateTime): Boolean; overload;
  end;

  { TfoDBTableFieldWord }

  TfoDBTableFieldWord = class(specialize TfoDBTableField<Word>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
    //procedure CopyValue(aTableField: TfoDBAbstractTableField); override;
    //function ValueEquals(aTableField: TfoDBTableFieldByte): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldShortInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSmallInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldInt64): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldQWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldBoolean): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSingle): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDouble): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldExtended): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldCurrency): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldString): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDateTime): Boolean; overload;
  end;

  { TfoDBTableFieldLongInt }

  TfoDBTableFieldLongInt = class(specialize TfoDBTableField<LongInt>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
    //procedure CopyValue(aTableField: TfoDBAbstractTableField); override;
    //function ValueEquals(aTableField: TfoDBTableFieldByte): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldShortInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSmallInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldInt64): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldQWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldBoolean): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSingle): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDouble): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldExtended): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldCurrency): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldString): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDateTime): Boolean; overload;
  end;

  { TfoDBTableFieldLongWord }

  TfoDBTableFieldLongWord = class(specialize TfoDBTableField<LongWord>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
    //procedure CopyValue(aTableField: TfoDBAbstractTableField); override;
    //function ValueEquals(aTableField: TfoDBTableFieldByte): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldShortInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSmallInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldInt64): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldQWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldBoolean): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSingle): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDouble): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldExtended): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldCurrency): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldString): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDateTime): Boolean; overload;
  end;

   { TfoDBTableFieldInt64 }

   TfoDBTableFieldInt64 = class(specialize TfoDBTableField<Int64>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
    //procedure CopyValue(aTableField: TfoDBAbstractTableField); override;
    //function ValueEquals(aTableField: TfoDBTableFieldByte): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldShortInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSmallInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldInt64): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldQWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldBoolean): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSingle): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDouble): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldExtended): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldCurrency): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldString): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDateTime): Boolean; overload;
  end;

  { TfoDBTableFieldQWord }

  TfoDBTableFieldQWord = class(specialize TfoDBTableField<QWord>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
    //procedure CopyValue(aTableField: TfoDBAbstractTableField); override;
    //function ValueEquals(aTableField: TfoDBTableFieldByte): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldShortInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSmallInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldInt64): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldQWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldBoolean): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSingle): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDouble): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldExtended): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldCurrency): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldString): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDateTime): Boolean; overload;
  end;

  // boolean type
  // http://www.freepascal.org/docs-html/ref/refsu5.html#x27-260003.1.1
  // Name	    Size	Ord(True)
  // Boolean	1	    1

  { TfoDBTableFieldBoolean }

  TfoDBTableFieldBoolean = class(specialize TfoDBTableField<Boolean>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
    //procedure CopyValue(aTableField: TfoDBAbstractTableField); override;
    //function ValueEquals(aTableField: TfoDBTableFieldByte): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldShortInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSmallInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldInt64): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldQWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldBoolean): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSingle): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDouble): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldExtended): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldCurrency): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldString): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDateTime): Boolean; overload;
  end;

  // real types
  // http://www.freepascal.org/docs-html/ref/refsu6.html#x28-310003.1.2

  // Type	      Range	                            Significant digits	  Size
  // Real	      platform dependant	 ???	                      4 or    8
  // Single	    1.5E-45               .. 3.4E38	                 7-8	  4
  // Double	    5.0E-324              .. 1.7E308	              15-16	  8
  // Extended	  1.9E-4932             .. 1.1E4932	              19-20	  10
  // Comp	      -2E64+1               .. 2E63-1	                19-20	  8
  // Currency	  -922337203685477.5808 .. 922337203685477.5807	  19-20	  8

  { TfoDBTableFieldSingle }

  TfoDBTableFieldSingle = class(specialize TfoDBTableField<Single>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
    //procedure CopyValue(aTableField: TfoDBAbstractTableField); override;
    //function ValueEquals(aTableField: TfoDBTableFieldByte): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldShortInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSmallInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldInt64): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldQWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldBoolean): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSingle): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDouble): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldExtended): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldCurrency): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldString): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDateTime): Boolean; overload;
  end;

  { TfoDBTableFieldDouble }

  TfoDBTableFieldDouble = class(specialize TfoDBTableField<Double>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
    //procedure CopyValue(aTableField: TfoDBAbstractTableField); override;
    //function ValueEquals(aTableField: TfoDBTableFieldByte): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldShortInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSmallInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldInt64): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldQWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldBoolean): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSingle): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDouble): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldExtended): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldCurrency): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldString): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDateTime): Boolean; overload;
  end;

  { TfoDBTableFieldExtended }

  TfoDBTableFieldExtended = class(specialize TfoDBTableField<Extended>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
    //procedure CopyValue(aTableField: TfoDBAbstractTableField); override;
    //function ValueEquals(aTableField: TfoDBTableFieldByte): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldShortInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSmallInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldInt64): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldQWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldBoolean): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSingle): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDouble): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldExtended): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldCurrency): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldString): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDateTime): Boolean; overload;
  end;

  { TfoDBTableFieldCurrency }

  TfoDBTableFieldCurrency = class(specialize TfoDBTableField<Currency>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
    //procedure CopyValue(aTableField: TfoDBAbstractTableField); override;
    //function ValueEquals(aTableField: TfoDBTableFieldByte): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldShortInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSmallInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldInt64): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldQWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldBoolean): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSingle): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDouble): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldExtended): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldCurrency): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldString): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDateTime): Boolean; overload;
  end;

  { TfoDBTableFieldString }

  TfoDBTableFieldString = class(specialize TfoDBTableField<String>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
    //procedure CopyValue(aTableField: TfoDBAbstractTableField); override;
    //function ValueEquals(aTableField: TfoDBTableFieldByte): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldShortInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSmallInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldInt64): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldQWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldBoolean): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSingle): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDouble): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldExtended): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldCurrency): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldString): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDateTime): Boolean; overload;
  end;

  { TfoDBTableFieldDateTime }

  TfoDBTableFieldDateTime = class(specialize TfoDBTableField<TDateTime>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
    //procedure CopyValue(aTableField: TfoDBAbstractTableField); override;
    //function ValueEquals(aTableField: TfoDBTableFieldByte): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldShortInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSmallInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongInt): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldLongWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldInt64): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldQWord): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldBoolean): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldSingle): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDouble): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldExtended): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldCurrency): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldString): Boolean; overload;
    //function ValueEquals(aTableField: TfoDBTableFieldDateTime): Boolean; overload;
  end;

implementation

{ TfoDBAbstractTableField }

procedure TfoDBAbstractTableField.SetIsNull(aIsNull: Boolean);
begin
  { If the field value is not already set to null }
  if fIsNull <> aIsNull then
    { Record that this fields value has now been changed }
    IsChanged := True;

  { Finally assign the new aIsNull value }
  fIsNull := aIsNull;

  { Remove any stored value if this field is now set to NULL, that would appear
    again if we were to assign this to not null again }
  if fIsNull then
    ClearValue;

  { TODO -oAPL -cDBTypes 5: What if the field is not nullable, should we give a
    warning then? Perpahs only when the field was assigned to something before?
    Since creating a new object with a not nullable field should be possible }
end;

procedure TfoDBAbstractTableField.SetIsChanged(aIsChanged: Boolean);
begin
  { Set whether ths value of this field has been changed }
  fIsChanged := aIsChanged;

  { Notify all oberservers that this field has changed value }
  NotifyAllObservers;
end;

constructor TfoDBAbstractTableField.Create(aOwnerTable: TfoDBTableObject; aFieldName: String);
begin
  inherited Create;

  { Assign the parameters of this constructor to the local variables in this
    instance for later usage }
  fOwnerTable := aOwnerTable;
  fFieldName := aFieldName;

  { Attach the owning table as an observer of this field }
  AttachObserver(fOwnerTable);

  { This field should add itself to the complete list of field in the owning
    tables field collection }
  fOwnerTable.AddTableField(Self);

  { Set initial state of the abstract field }
  fIsNull := True;
  fIsChanged := False;
  fIsPrimaryKey := False;
  fIsIndexed := False;
  fIsForeignKey := False;
  fHasDefault := False;
  fIsNullable := False;

  { Clear the value of this field upon creation }
  ClearValue;
end;

destructor TfoDBAbstractTableField.Destroy;
begin
  inherited Destroy;
end;

{ TfoDBTableFieldDateTime }

destructor TfoDBTableFieldDateTime.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldDateTime.ClearValue;
begin
  inherited ClearValue;
  fValue := 0;
end;

function TfoDBTableFieldDateTime.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
  begin
    Result := FormatDateTime(c_SQL_DateTimeFormat, fValue);
    Result := ToSqlStr(Result);
  end;
end;

function TfoDBTableFieldDateTime.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    { TODO -oAPL -cDBTypes 5: Need to do more work around converting a TDateTime value to XML, need to use some actual XML datetime transforming code }
    Result := FormatDateTime(c_XML_DateTimeFormat, fValue);
end;

function TfoDBTableFieldDateTime.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := FormatDateTime(c_String_DateTimeFormat, fValue);
end;

{ TfoDBTableFieldString }

destructor TfoDBTableFieldString.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldString.ClearValue;
begin
  inherited ClearValue;
  fValue := '';
end;

function TfoDBTableFieldString.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
    Result := ToSqlStr(fValue);
end;

function TfoDBTableFieldString.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    Result := fValue;
end;

function TfoDBTableFieldString.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := fValue;
end;

{ TfoDBTableFieldCurrency }

destructor TfoDBTableFieldCurrency.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldCurrency.ClearValue;
begin
  inherited ClearValue;
  fValue := 0;
end;

function TfoDBTableFieldCurrency.ToSql: String;
var
  tmpSep: Char;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_SQL_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

function TfoDBTableFieldCurrency.ToXML: String;
var
  tmpSep: Char;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_XML_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

function TfoDBTableFieldCurrency.AsString: String;
var
  tmpSep: Char;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_String_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

{ TfoDBTableFieldExtended }

destructor TfoDBTableFieldExtended.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldExtended.ClearValue;
begin
  inherited ClearValue;
  fValue := 0;
end;

function TfoDBTableFieldExtended.ToSql: String;
var
  tmpSep: Char;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_SQL_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

function TfoDBTableFieldExtended.ToXML: String;
var
  tmpSep: Char;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_XML_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

function TfoDBTableFieldExtended.AsString: String;
var
  tmpSep: Char;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_String_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

{ TfoDBTableFieldDouble }

destructor TfoDBTableFieldDouble.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldDouble.ClearValue;
begin
  inherited ClearValue;
  fValue := 0;
end;

function TfoDBTableFieldDouble.ToSql: String;
var
  tmpSep: Char;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_SQL_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

function TfoDBTableFieldDouble.ToXML: String;
var
  tmpSep: Char;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_XML_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

function TfoDBTableFieldDouble.AsString: String;
var
  tmpSep: Char;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_String_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

{ TfoDBTableFieldSingle }

destructor TfoDBTableFieldSingle.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldSingle.ClearValue;
begin
  inherited ClearValue;
  fValue := 0;
end;

function TfoDBTableFieldSingle.ToSql: String;
var
  tmpSep: Char;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_SQL_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

function TfoDBTableFieldSingle.ToXML: String;
var
  tmpSep: Char;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_XML_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

function TfoDBTableFieldSingle.AsString: String;
var
  tmpSep: Char;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_String_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

{ TfoDBTableFieldBoolean }

destructor TfoDBTableFieldBoolean.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldBoolean.ClearValue;
begin
  inherited ClearValue;
  fValue := False;
end;

function TfoDBTableFieldBoolean.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else Result := c_SQL_Boolean[fValue];
end;

function TfoDBTableFieldBoolean.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else Result := c_XML_Boolean[fValue];
end;

function TfoDBTableFieldBoolean.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else Result := c_String_Boolean[fValue];
end;

{ TfoDBTableFieldQWord }

destructor TfoDBTableFieldQWord.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldQWord.ClearValue;
begin
  inherited ClearValue;
  fValue := 0;
end;

function TfoDBTableFieldQWord.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldQWord.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldQWord.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := IntToStr(fValue);
end;

{ TfoDBTableFieldInt64 }

destructor TfoDBTableFieldInt64.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldInt64.ClearValue;
begin
  inherited ClearValue;
  fValue := 0;
end;

function TfoDBTableFieldInt64.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldInt64.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldInt64.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := IntToStr(fValue);
end;

{ TfoDBTableFieldLongWord }

destructor TfoDBTableFieldLongWord.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldLongWord.ClearValue;
begin
  inherited ClearValue;
  fValue := 0;
end;

function TfoDBTableFieldLongWord.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldLongWord.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldLongWord.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := IntToStr(fValue);
end;

{ TfoDBTableFieldWord }

destructor TfoDBTableFieldWord.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldWord.ClearValue;
begin
  inherited ClearValue;
  fValue := 0;
end;

function TfoDBTableFieldWord.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldWord.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldWord.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := IntToStr(fValue);
end;

{ TfoDBTableFieldShortInt }

destructor TfoDBTableFieldShortInt.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldShortInt.ClearValue;
begin
  inherited ClearValue;
  fValue := 0;
end;

function TfoDBTableFieldShortInt.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldShortInt.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldShortInt.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := IntToStr(fValue);
end;

{ TfoDBTableFieldByte }

destructor TfoDBTableFieldByte.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldByte.ClearValue;
begin
  inherited ClearValue;
  fValue := 0;
end;

function TfoDBTableFieldByte.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldByte.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldByte.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := IntToStr(fValue);
end;

procedure TfoDBTableFieldByte.CopyValue(aTableField: TfoDBAbstractTableField);
begin
  inherited CopyValue(aTableField);

  if (aTableField.ClassType = TfoDBTableFieldByte) then
    Value := TfoDBTableFieldByte(aTableField).Value
  else if (aTableField.ClassType = TfoDBTableFieldShortInt) then
  begin
    Value := TfoDBTableFieldByte(aTableField).Value
  end
  else if (aTableField.ClassType = TfoDBTableFieldSmallInt) then begin end
  else if (aTableField.ClassType = TfoDBTableFieldWord) then begin end
  else if (aTableField.ClassType = TfoDBTableFieldLongInt) then begin end
  else if (aTableField.ClassType = TfoDBTableFieldLongWord) then begin end
  else if (aTableField.ClassType = TfoDBTableFieldInt64) then begin end
  else if (aTableField.ClassType = TfoDBTableFieldQWord) then begin end
  else if (aTableField.ClassType = TfoDBTableFieldBoolean) then begin end
  else if (aTableField.ClassType = TfoDBTableFieldSingle) then begin end
  else if (aTableField.ClassType = TfoDBTableFieldDouble) then begin end
  else if (aTableField.ClassType = TfoDBTableFieldExtended) then begin end
  else if (aTableField.ClassType = TfoDBTableFieldCurrency) then begin end
  else if (aTableField.ClassType = TfoDBTableFieldString) then begin end
  else if (aTableField.ClassType = TfoDBTableFieldDateTime) then begin end
  else
  begin

  end

end;

{ TfoDBTableFieldSmallInt }

destructor TfoDBTableFieldSmallInt.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldSmallInt.ClearValue;
begin
  inherited ClearValue;
  fValue := 0;
end;

function TfoDBTableFieldSmallInt.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldSmallInt.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldSmallInt.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := IntToStr(fValue);
end;

{ TfoDBTableFieldLongInt }

destructor TfoDBTableFieldLongInt.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldLongInt.ClearValue;
begin
  inherited ClearValue;
  fValue := 0;
end;

function TfoDBTableFieldLongInt.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldLongInt.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldLongInt.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := IntToStr(fValue);
end;

{ TfoDBTableInformation }

constructor TfoDBTableInformation.Create;
begin
  inherited Create;
end;

destructor TfoDBTableInformation.Destroy;
begin
  inherited Destroy;
end;

constructor TfoDBTableField.Create(aOwnerTable: TfoDBTableObject; aFieldName: String);
begin
  { Call inherited create }
  inherited Create(aOwnerTable, aFieldName);
end;

destructor TfoDBTableField.Destroy;
begin
  { Call inherited destroy  }
  inherited Destroy;
end;

procedure TfoDBTableField.CopyValue(aTableField: TfoDBAbstractTableField);
begin
  { Does nothing at this stage, only implemented because I don't seem to be able
    to inherit an abstract function into another abstract function }
end;

function TfoDBTableField.ToSql: String;
begin
  { Does nothing at this stage, only implemented because I don't seem to be able
    to inherit an abstract function into another abstract function }
  Result := '';
end;

function TfoDBTableField.ToXML: String;
begin
  { Does nothing at this stage, only implemented because I don't seem to be able
    to inherit an abstract function into another abstract function }
  Result := '';
end;

function TfoDBTableField.AsString: String;
begin
  { Does nothing at this stage, only implemented because I don't seem to be able
    to inherit an abstract function into another abstract function }
  Result := '';
end;

procedure TfoDBTableField.SetValue(aValue: T);
begin
  { If the field value is set to null, then assign the new value to the internal
    variable, and set the IsNull field to False. This will cause the IsChanged
    property to be set to True in turn, since the value of IsNull is true before
    the assignment. That will in turn also kick off the NotifyAllObservers
    function call }
  if IsNull then
  begin
    fValue := aValue;
    IsNull := False;
  end
  { If the field value is not null and the new value is different from the old
    one, then assign the new value, and set the field to IsChanged = true }
  else if (fValue <> aValue) then
  begin
    fValue := aValue;
    IsChanged := True;
  end;
  { There is a final case here, where IsNull is false and the passed value and
    current value are identical. In this case, no change should be made, and
    no observers should be notified about a change }
end;

procedure TfoDBTableField.ClearValue;
begin
  { Does nothing at this stage, only implemented because I don't seem to be able
    to inherit an abstract procedure into another abstract procefure }
end;

{ TfoDBTableObject }

function TfoDBTableObject.OpenConnection: Boolean;
const
  lProcedureName = 'OpenConnection';
begin
  { Default result is that we did not connect }
  Result := False;

  { Check the local class connection variable }
  if not Assigned(fConnection) then
    raise Exception.Create(Self.ClassName + '.' + lProcedureName + ': ' +
      'Unable to add field to table object, the local fConnection is not assigned.');

  { Set the local flag, that indicates if this instance opened the connection (
    interresting when doing nested inserts and we do not want to open and close
    the connection a lot of times, but jus trather want the initiator objec to
    open, and then finally close the connection we are using. }
  fOpenedConnection := False;

  { If the connection is not already connected, then open the connection and
    set the local flag that indicates that this instance is responsible for
    closing the connection again. }
  try
    if not fConnection.Connected then
    begin
      fConnection.Open();
      Result := True;
      fOpenedConnection := True;
    end
    else
      { In case the connection is already open, return True to indicate that the
        connection 'was opened', so that the calling code may proceed, assuming
        that the connection is open. }
      Result := True;

    { If an exception occurrs when connecting, set the Result to false and
      reraise the exception. }
    except on e:Exception do
    begin
      Result := False;
      raise;
    end;
  end;
end;

function TfoDBTableObject.CloseConnection(aConsumeException: Boolean): Boolean;
const
  lProcedureName = 'CloseConnection';
begin
  { Default result is that we did were unsuccessful }
  Result := False;

  { Check the local class connection variable }
  if not Assigned(fConnection) then
    raise Exception.Create(Self.ClassName + '.' + lProcedureName + ': ' +
      'Unable to add field to table object, the local fConnection is not assigned.');

  { Attempt to close the connection, if this instance was the initiator of the
    connection. }
  try
    if fOpenedConnection then
      fConnection.Close;

    Result := True;

    { If an exception occurrs when disconnecting, set the Result to false and
      reraise the exception. }
    except on e:Exception do
    begin
      Result := False;
      { If the called asked not to 'mute' this exception, then raise it again. }
      if not aConsumeException then
        raise;
    end;
  end;
end;

procedure TfoDBTableObject.AddTableField(aTableField: TfoDBAbstractTableField);
const
  lProcedureName = 'AddTableField';
begin
  { Check the local class variable }
  if not Assigned(fFieldList) then
    raise Exception.Create(Self.ClassName + '.' + lProcedureName + ': ' +
      'Unable to add field to table object, the local fFieldList is not assigned.');

  { Check the input parameter }
  if not Assigned(aTableField) then
    raise Exception.Create(Self.ClassName + '.' + lProcedureName + ': ' +
      'Unable to add field to table object, the aTableField parameter is not assigned.');

  { Add the field to the internal field list }
  fFieldList.Add(aTableField);
end;

constructor TfoDBTableObject.Create(aConnection: TSQLConnector; aMutex: TCriticalSection);
begin
  inherited Create;

  { Assign the connection and mutex to be used to the local variables }
  fConnection := aConnection;
  fMutex := aMutex;

  { Create the local state holder object and the object that holds some table
    information about the table that the decendant class wraps }
  fTableInformation := TfoDBTableInformation.Create;
  fObjectStatus := TfoDBTableStatus.Create(Self);

  { Set the initial destroying state }
  fIsDestroying := False;

  { Create the local fieldlist, that will hold all field references. Fields will
    also be available by their name and specific type in the autogenerated
    decending classes }
  fFieldList := TfoDBTableFieldList.Create;
end;

destructor TfoDBTableObject.Destroy;
begin
  { Free the local object types }
  if Assigned(fObjectStatus) then
    fObjectStatus.Free;

  if Assigned(fTableInformation) then
    fTableInformation.Free;

  { Call the inherited destructor }
  inherited Destroy;
end;

procedure TfoDBTableObject.ReceiveSubjectUpdate(aSubject: IfoObserverSubject);
begin
  { A field has changed }

  { TODO -oAPL -cDBTypes 3: Perhaps control the state of the table status from
    here? }
end;

function TfoDBTableObject.Insert: Boolean;
const
  lProcedureName = 'Insert';
begin
  Result := False;

  try
    try
      if OpenConnection then
      begin
        { TODO -oAPL -cDBTypes 1: Implement this feature, inserting at this
          abstact level! }
        { Insert objects that are foreign key referenced from this object }
        { Insert this object }
        { Insert lists of objects that are referencing this object with a
          foreign key in their own table. }
      end;

      except on e:Exception do
      begin
        { Something went wrong, while opening connection or after, while
          inserting. }
      end
    end;

    finally
    begin
      { Attempt to close the connection, the procedure will check if this object
        is the initiator of the connection, and only close it if that is the
        case. }
      CloseConnection;
    end;
  end;
end;


{ TfoDBTableStatus }

constructor TfoDBTableStatus.Create(aOwnerTable: TfoDBTableObject);
begin
  inherited Create;

  fOwnerTable := aOwnerTable;

  fIsNew := True;
  fIsLoaded := False;
  fIsChanged := False;
  fIsDeleted := False;

  fCreatedTime := Now;
  fSavedTime := 0;
  fLoadedTime := 0;
  fChangedTime := 0;
  fDeletedTime := 0;
end;

destructor TfoDBTableStatus.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableStatus.SetIsNew(aIsNew: Boolean);
begin
  { User is setting this object to a 'new' state, while it actually is an object
    that has been changed at some point, since fIsNew is no longer true. The
    user may be trying to save a copy of the object or something. Set the object
    to a 'newly created' state. }
  if (not fIsNew) and aIsNew then
  begin
    fIsNew := aIsNew;
    fIsLoaded := False;
    fIsChanged := False;
    fIsDeleted := False;

    fCreatedTime := Now;
    fSavedTime := 0;
    fLoadedTime := 0;
    fChangedTime := 0;
    fDeletedTime := 0;
  end;
end;

procedure TfoDBTableStatus.SetIsLoaded(aIsLoaded: Boolean);
begin
  { Set the local object IsLoaded value to the parameter }
  fIsLoaded := aIsLoaded;

  { If this object is now loaded, set the LoadedTime to now. Should I set it to
    0 if the fIsLoaded flag is set to false? }
  if fIsLoaded then
    fLoadedTime := Now;
end;

procedure TfoDBTableStatus.SetIsChanged(aIsChanged: Boolean);
begin
  { Set the local object IsChanged value to the parameter }
  fIsChanged := aIsChanged;

  { If this object is now changed set the ChangedTime to now, otherwise should
    it be set to 0? }
  if fIsChanged then
    fChangedTime := Now;
end;

procedure TfoDBTableStatus.SetIsDeleted(aIsDeleted: Boolean);
begin
  { Update the local fIsDeleted flag }
  fIsDeleted := aIsDeleted;

  { If this object was deleted, set the deleted time to now, otherwise set it to
    0 - if the object is 'not deleted' }
  if fIsDeleted then
    fDeletedTime := Now
  else
    fDeletedTime := 0;
end;

end.

