unit fpcormdbobjects;

{< @abstract(This unit contains all the super types, derived into the types
     written in the code generated by fpcORM.)
   @author(Andreas Lorenzen - aplorenzen@gmail.com)
   @created(2014-06-24)

   The classes in this unit, are intended to provide all the basic functionality
   for the final types that are genererated by the fpcORM. Types representing
   the database table and table fields are here, with functions that supplies
   all the fundamental functionality, of maintaining the state of the derived
   objects. }

{$mode objfpc}{$H+}

interface

uses
  Classes,
  SysUtils,
  SyncObjs,
  SQLDB,
  FGL,

  fpcormdbutils,
  fpcormdbconstants;

type
  { forward declaration of interfaces }
  IfoDBObject = interface;
  IfoDBTable = interface;
  IfoDBTableField = interface;

  { forward declaration of classes }
  TfoDBTable = class;
  TfoDBObjectStatus = class;
  TfoDBTableInformation = class;
  { seems that one cannot make forward declaration of generic or specialized types? }
  { TfoDBTableField = class; }
  { TfoDBTableFieldList = class; }

  {  }

  IfoDBObject = interface(IInterface)
    ['{3BCDE6E8-2406-4FE1-9584-E16DD5B7496E}']
    function GetConnection(): TSQLConnector;
    procedure SetConnection(aConnection: TSQLConnector);
  end;

  IfoDBTable = interface(IfoDBObject)
    ['{57363BA5-AF19-42FE-A7F6-3C52096D24C0}']
    function GetTableInformation(): TfoDBTableInformation;
    procedure SetTableInformation(aTableInformation: TfoDBTableInformation);
  end;

  IfoDBTableField = interface(IInterface)
    ['{C1C665A2-6F77-418B-B4A0-50B4F9B65239}']
    function GetFieldName: String;
    procedure SetFieldName(aFieldName: String);
    function GetIsNull: Boolean;
    procedure SetIsNull(aIsNull: Boolean);
    function GetIsAssigned: Boolean;
    procedure SetIsAssigned(aIsAssigned: Boolean);
    function GetIsChanged: Boolean;
    procedure SetIsChanged(aIsChanged: Boolean);
    function GetIsIndexed: Boolean;
    procedure SetIsIndexed(aIsIndexed: Boolean);
    function GetIsForeignKey: Boolean;
    procedure SetIsForeignKey(aIsForeignKey: Boolean);
    function GetIsPrimaryKey: Boolean;
    procedure SetIsPrimaryKey(aIsPrimaryKey: Boolean);
    function GetHasDefault: Boolean;
    procedure SetHasDefault(aHasDefault: Boolean);
    function GetOwnerTable: TfoDBTable;
    procedure SetOwnerTable(AOwnerTable: TfoDBTable);
    function ToSql(): String;
    function ToXML(): String;
    function AsString(): String;
  end;

  { TfoDBObjectStatus }

  TfoDBObjectStatus = class(TInterfacedPersistent)
  private
    fIsNew: Boolean;
    fIsLoaded: Boolean;
    fIsChanged: Boolean;
    fIsDeleted: Boolean;

    fCreatedTime: TDateTime;
    fLoadedTime: TDateTime;
    fChangedTime: TDateTime;
    fSavedTime: TDateTime;
    fDeletedTime: TDateTime;

    function GetIsNew(): Boolean;
    procedure SetIsNew(aIsNew: Boolean);
    function GetIsLoaded(): Boolean;
    procedure SetIsLoaded(aIsLoaded: Boolean);
    function GetIsChanged(): Boolean;
    procedure SetIsChanged(aIsChanged: Boolean);
    function GetIsDeleted(): Boolean;
    procedure SetIsDeleted(aIsDeleted: Boolean);
    function GetCreatedTime(): TDateTime;
    procedure SetCreatedTime(aCreatedTime: TDateTime);
    function GetLoadedTime(): TDateTime;
    procedure SetLoadedTime(aLoadedTime: TDateTime);
    function GetChangedTime(): TDateTime;
    procedure SetChangedTime(aChangedTime: TDateTime);
    function GetSavedTime(): TDateTime;
    procedure SetSavedTime(aSavedTime: TDateTime);
    function GetDeletedTime(): TDateTime;
    procedure SetDeletedTime(aDeletedTime: TDateTime);
  public
    constructor Create;
    destructor Destroy; override;

    property IsNew: Boolean read GetIsNew write SetIsNew;
    property IsLoaded: Boolean read GetIsLoaded write SetIsLoaded;
    property IsChanged: Boolean read GetIsChanged write SetIsChanged;
    property IsDeleted: Boolean read GetIsDeleted write SetIsDeleted;

    property CreatedTime: TDateTime read GetCreatedTime write SetCreatedTime;
    property LoadedTime: TDateTime read GetLoadedTime write SetLoadedTime;
    property ChangedTime: TDateTime read GetChangedTime write SetChangedTime;
    property SavedTime: TDateTime read GetSavedTime write SetSavedTime;
    property DeletedTime: TDateTime read GetDeletedTime write SetDeletedTime;
  end;

  { TfoDBTableInformation }

  TfoDBTableInformation = class(TInterfacedPersistent)
  private
    fTableCatalog: String;
    fTableSchema: String;
    fTableName: String;
    fTableType: String;
    // TODO -oAPL -cDBTypes 4: TfoDBTableInformation: More fields here, steal from dORM, list of PK items and FK items, indexed things and more
  public
    constructor Create;
    destructor Destroy; override;
    // TODO -oAPL -cDBTypes 2: TfoDBTableInformation: Implement getters, setters and properties here
  end;

  { TfoTableField }

  generic TfoDBTableField<T> = class(TInterfacedPersistent, IfoDBTableField)
  private
    fOwnerTable: TfoDBTable;
    fValue: T;
    fFieldName: String;
    fIsNull: Boolean;
    fIsAssigned: Boolean;
    fIsChanged: Boolean;
    fIsIndexed: Boolean;
    fIsPrimaryKey: Boolean;
    fIsForeignKey: Boolean;
    fHasDefault: Boolean;

    function GetValue: T;
    procedure SetValue(aValue: T);
    function GetFieldName: String;
    procedure SetFieldName(aFieldName: String);
    function GetIsNull: Boolean;
    procedure SetIsNull(aIsNull: Boolean);
    function GetIsAssigned: Boolean;
    procedure SetIsAssigned(aIsAssigned: Boolean);
    function GetIsChanged: Boolean;
    procedure SetIsChanged(aIsChanged: Boolean);
    function GetIsIndexed: Boolean;
    procedure SetIsIndexed(aIsIndexed: Boolean);
    function GetIsForeignKey: Boolean;
    procedure SetIsForeignKey(aIsForeignKey: Boolean);
    function GetIsPrimaryKey: Boolean;
    procedure SetIsPrimaryKey(aIsPrimaryKey: Boolean);
    function GetHasDefault: Boolean;
    procedure SetHasDefault(aHasDefault: Boolean);
    function GetOwnerTable: TfoDBTable;
    procedure SetOwnerTable(aOwnerTable: TfoDBTable);
  public
    constructor Create(aOwnerTable: TfoDBTable); overload;
    constructor Create(aOwnerTable: TfoDBTable; aValue: T; aFieldName: String = ''); overload;
    destructor Destroy; override;

    procedure ClearValue; virtual;
    function ToSql(): String; virtual;
    function ToXML(): String; virtual;
    function AsString(): String; virtual;
    function ValueEquals(aValue: T): Boolean;

    property Value: T read GetValue write SetValue;
    property IsNull: Boolean read GetIsNull write SetIsNull;
    property IsAssigned: Boolean read GetIsAssigned write SetIsAssigned;

    property IsPrimaryKey: Boolean read GetIsPrimaryKey write SetIsPrimaryKey;
    property IsIndexed: Boolean read GetIsIndexed write SetIsIndexed;
    property IsForeignKey: Boolean read GetIsForeignKey write SetIsForeignKey;
    property HasDefault: Boolean read GetHasDefault write SetHasDefault;
    property IsChanged: Boolean read GetIsChanged write SetIsChanged;
    property FieldName: String read GetFieldName write SetFieldName;
    property OwnerTable: TfoDBTable read GetOwnerTable write SetOwnerTable;
  end;

  { TfoDBTableFieldList }

  TfoDBTableFieldList = specialize TFPGList<IfoDBTableField>;

  { TfoDBTable }

  TfoDBTable = class(TInterfacedPersistent, IfoDBTable)
  private
    fConnection: TSQLConnector;
    fTableInformation: TfoDBTableInformation;
    fMutex: TCriticalSection;
    fObjectStatus: TfoDBObjectStatus;
    fFieldList: TfoDBTableFieldList;
    fIsDestroying: Boolean;

    procedure SetConnection(aConnection: TSQLConnector);
    function GetConnection(): TSQLConnector;
    function GetFieldList: TfoDBTableFieldList;
    procedure SetFieldList(aFieldList: TfoDBTableFieldList);
    procedure SetTableInformation(aTableInformation: TfoDBTableInformation);
    function GetTableInformation(): TfoDBTableInformation;
    function GetIsDestroying(): Boolean;
    procedure SetIsDestroying(AIsDestroying: Boolean);
    function GetMutex(): TCriticalSection;
    procedure SetMutex(aMutex: TCriticalSection);
    function GetObjectStatus: TfoDBObjectStatus;
    procedure SetObjectStatus(aObjectStatus: TfoDBObjectStatus);
  public
    constructor Create(aConnection: TSQLConnector; aMutex: TCriticalSection);
    destructor Destroy; override;

    // the LoadedOrNotNew function may not be nessecary, it was used to 'probe' if an instance was loaded, when using lazyloading
    // function LoadedOrNotNew(AFreeIfNot: Boolean = True): Boolean;
    property Connection: TSQLConnector read GetConnection write SetConnection;
    property TableInformation: TfoDBTableInformation read GetTableInformation write SetTableInformation;
    property Mutex: TCriticalSection read GetMutex write SetMutex;
    property ObjectStatus: TfoDBObjectStatus read GetObjectStatus write SetObjectStatus;
    property FieldList: TfoDBTableFieldList read GetFieldList write SetFieldList;
    property IsDestroying: Boolean read GetIsDestroying write SetIsDestroying;
  end;

  // integer types
  // http://www.freepascal.org/docs-html/ref/refsu5.html#x27-260003.1.1

  // Type	      Range	                                        Size in bytes
  // Byte	      0 .. 255	                                    1
  // Shortint	 -128 .. 127	                                  1
  // Smallint	 -32768 .. 32767	                              2
  // Word	      0 .. 65535	                                  2
  // Integer	 either smallint or longint	                    size 2 or 4
  // Cardinal	 longword	                                      4
  // Longint	 -2147483648 .. 2147483647	                    4
  // Longword	  0 .. 4294967295	                              4
  // Int64	    -9223372036854775808 .. 9223372036854775807	  8
  // QWord	    0 .. 18446744073709551615	                    8


  { TfoDBTableFieldByte }

  TfoDBTableFieldByte = class(specialize TfoDBTableField<Byte>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
  end;

  { TfoDBTableFieldShortInt }

  TfoDBTableFieldShortInt = class(specialize TfoDBTableField<ShortInt>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
  end;

  { TfoDBTableFieldSmallInt }

  TfoDBTableFieldSmallInt = class(specialize TfoDBTableField<SmallInt>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
  end;

  { TfoDBTableFieldWord }

  TfoDBTableFieldWord = class(specialize TfoDBTableField<Word>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
  end;

  { TfoDBTableFieldLongInt }

  TfoDBTableFieldLongInt = class(specialize TfoDBTableField<LongInt>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
  end;

  { TfoDBTableFieldLongWord }

  TfoDBTableFieldLongWord = class(specialize TfoDBTableField<LongWord>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
  end;

   { TfoDBTableFieldInt64 }

   TfoDBTableFieldInt64 = class(specialize TfoDBTableField<Int64>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
  end;

  { TfoDBTableFieldQWord }

  TfoDBTableFieldQWord = class(specialize TfoDBTableField<QWord>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
  end;

  // boolean type
  // http://www.freepascal.org/docs-html/ref/refsu5.html#x27-260003.1.1
  // Name	    Size	Ord(True)
  // Boolean	1	    1

  { TfoDBTableFieldBoolean }

  TfoDBTableFieldBoolean = class(specialize TfoDBTableField<Boolean>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
  end;

  // real types
  // http://www.freepascal.org/docs-html/ref/refsu6.html#x28-310003.1.2

  // Type	      Range	                            Significant digits	  Size
  // Real	      platform dependant	 ???	                      4 or    8
  // Single	    1.5E-45               .. 3.4E38	                 7-8	  4
  // Double	    5.0E-324              .. 1.7E308	              15-16	  8
  // Extended	  1.9E-4932             .. 1.1E4932	              19-20	  10
  // Comp	      -2E64+1               .. 2E63-1	                19-20	  8
  // Currency	  -922337203685477.5808 .. 922337203685477.5807	  19-20	  8

  { TfoDBTableFieldSingle }

  TfoDBTableFieldSingle = class(specialize TfoDBTableField<Single>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
  end;

  { TfoDBTableFieldDouble }

  TfoDBTableFieldDouble = class(specialize TfoDBTableField<Double>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
  end;

  { TfoDBTableFieldExtended }

  TfoDBTableFieldExtended = class(specialize TfoDBTableField<Extended>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
  end;

  { TfoDBTableFieldCurrency }

  TfoDBTableFieldCurrency = class(specialize TfoDBTableField<Currency>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
  end;

  { TfoDBTableFieldString }

  TfoDBTableFieldString = class(specialize TfoDBTableField<String>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
  end;

  { TfoDBTableFieldDateTime }

  TfoDBTableFieldDateTime = class(specialize TfoDBTableField<TDateTime>)
  public
    destructor Destroy; override;

    procedure ClearValue; override;
    function ToSql(): String; override;
    function ToXML(): String; override;
    function AsString(): String; override;
  end;

implementation

{ TfoDBTableFieldDateTime }

destructor TfoDBTableFieldDateTime.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldDateTime.ClearValue;
begin
  inherited ClearValue;

  fValue := 0;
end;

function TfoDBTableFieldDateTime.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
  begin
    Result := FormatDateTime(c_SQL_DateTimeFormat, fValue);
    Result := ToSqlStr(Result);
  end;
end;

function TfoDBTableFieldDateTime.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    { TODO -oAPL -cDBTypes 5: Need to do more work around converting a TDateTime value to XML, need to use some actual XML datetime transforming code }
    Result := FormatDateTime(c_XML_DateTimeFormat, fValue);
end;

function TfoDBTableFieldDateTime.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := FormatDateTime(c_String_DateTimeFormat, fValue);
end;

{ TfoDBTableFieldString }

destructor TfoDBTableFieldString.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldString.ClearValue;
begin
  inherited ClearValue;

  fValue := '';
end;

function TfoDBTableFieldString.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
    Result := ToSqlStr(fValue);
end;

function TfoDBTableFieldString.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    Result := fValue;
end;

function TfoDBTableFieldString.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := fValue;
end;

{ TfoDBTableFieldCurrency }

destructor TfoDBTableFieldCurrency.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldCurrency.ClearValue;
begin
  inherited ClearValue;

  fValue := 0;
end;

function TfoDBTableFieldCurrency.ToSql: String;
var
  tmpSep: Char;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_SQL_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

function TfoDBTableFieldCurrency.ToXML: String;
var
  tmpSep: Char;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_XML_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

function TfoDBTableFieldCurrency.AsString: String;
var
  tmpSep: Char;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_String_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

{ TfoDBTableFieldExtended }

destructor TfoDBTableFieldExtended.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldExtended.ClearValue;
begin
  inherited ClearValue;

  fValue := 0;
end;

function TfoDBTableFieldExtended.ToSql: String;
var
  tmpSep: Char;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_SQL_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

function TfoDBTableFieldExtended.ToXML: String;
var
  tmpSep: Char;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_XML_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

function TfoDBTableFieldExtended.AsString: String;
var
  tmpSep: Char;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_String_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

{ TfoDBTableFieldDouble }

destructor TfoDBTableFieldDouble.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldDouble.ClearValue;
begin
  inherited ClearValue;

  fValue := 0;
end;

function TfoDBTableFieldDouble.ToSql: String;
var
  tmpSep: Char;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_SQL_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

function TfoDBTableFieldDouble.ToXML: String;
var
  tmpSep: Char;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_XML_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

function TfoDBTableFieldDouble.AsString: String;
var
  tmpSep: Char;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_String_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

{ TfoDBTableFieldSingle }

destructor TfoDBTableFieldSingle.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldSingle.ClearValue;
begin
  inherited ClearValue;

  fValue := 0;
end;

function TfoDBTableFieldSingle.ToSql: String;
var
  tmpSep: Char;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_SQL_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

function TfoDBTableFieldSingle.ToXML: String;
var
  tmpSep: Char;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_XML_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

function TfoDBTableFieldSingle.AsString: String;
var
  tmpSep: Char;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
  begin
    tmpSep := FormatSettings.DecimalSeparator;

    try
      FormatSettings.DecimalSeparator := c_String_DecimalSeparatorChar;

      Result := FloatToStr(fValue);

      finally
        FormatSettings.DecimalSeparator := tmpSep;
    end;
  end;
end;

{ TfoDBTableFieldBoolean }

destructor TfoDBTableFieldBoolean.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldBoolean.ClearValue;
begin
  inherited ClearValue;

  fValue := False;
end;

function TfoDBTableFieldBoolean.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else Result := c_SQL_Boolean[fValue];
end;

function TfoDBTableFieldBoolean.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else Result := c_XML_Boolean[fValue];
end;

function TfoDBTableFieldBoolean.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else Result := c_String_Boolean[fValue];
end;

{ TfoDBTableFieldQWord }

destructor TfoDBTableFieldQWord.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldQWord.ClearValue;
begin
  inherited ClearValue;

  fValue := 0;
end;

function TfoDBTableFieldQWord.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldQWord.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldQWord.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := IntToStr(fValue);
end;

{ TfoDBTableFieldInt64 }

destructor TfoDBTableFieldInt64.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldInt64.ClearValue;
begin
  inherited ClearValue;

  fValue := 0;
end;

function TfoDBTableFieldInt64.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldInt64.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldInt64.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := IntToStr(fValue);
end;

{ TfoDBTableFieldLongWord }

destructor TfoDBTableFieldLongWord.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldLongWord.ClearValue;
begin
  inherited ClearValue;

  fValue := 0;
end;

function TfoDBTableFieldLongWord.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldLongWord.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldLongWord.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := IntToStr(fValue);
end;

{ TfoDBTableFieldWord }

destructor TfoDBTableFieldWord.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldWord.ClearValue;
begin
  inherited ClearValue;

  fValue := 0;
end;

function TfoDBTableFieldWord.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldWord.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldWord.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := IntToStr(fValue);
end;

{ TfoDBTableFieldShortInt }

destructor TfoDBTableFieldShortInt.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldShortInt.ClearValue;
begin
  inherited ClearValue;

  fValue := 0;
end;

function TfoDBTableFieldShortInt.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldShortInt.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldShortInt.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := IntToStr(fValue);
end;

{ TfoDBTableFieldByte }

destructor TfoDBTableFieldByte.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldByte.ClearValue;
begin
  inherited ClearValue;

  fValue := 0;
end;

function TfoDBTableFieldByte.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldByte.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldByte.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := IntToStr(fValue);
end;

{ TfoDBTableFieldSmallInt }

destructor TfoDBTableFieldSmallInt.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldSmallInt.ClearValue;
begin
  inherited ClearValue;

  fValue := 0;
end;

function TfoDBTableFieldSmallInt.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldSmallInt.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldSmallInt.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := IntToStr(fValue);
end;

{ TfoDBTableFieldLongInt }

destructor TfoDBTableFieldLongInt.Destroy;
begin
  inherited Destroy;
end;

procedure TfoDBTableFieldLongInt.ClearValue;
begin
  inherited ClearValue;

  fValue := 0;
end;

function TfoDBTableFieldLongInt.ToSql: String;
begin
  Result := inherited ToSql;

  if fIsNull then
    Result := c_SQL_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldLongInt.ToXML: String;
begin
  Result := inherited ToXML;

  if fIsNull then
    Result := c_XML_NULL
  else
    Result := IntToStr(fValue);
end;

function TfoDBTableFieldLongInt.AsString: String;
begin
  Result := inherited AsString;

  if fIsNull then
    Result := c_String_NULL
  else
    Result := IntToStr(fValue);
end;

{ TfoDBTableInformation }

constructor TfoDBTableInformation.Create;
begin
  inherited Create;
end;

destructor TfoDBTableInformation.Destroy;
begin
  inherited Destroy;
end;

{ TfoTableField }

constructor TfoDBTableField.Create(aOwnerTable: TfoDBTable);
begin
  // call create in TInterfacedPersistent
  inherited Create;

  // assign the parsed owner table, to the local owner table
  fOwnerTable := aOwnerTable;

  // set up defaults of the generic type database field
  fIsNull := True;
  fIsAssigned := False;
  fIsChanged := False;
  fIsIndexed := False;
  fIsPrimaryKey := False;
  fIsForeignKey := False;
  fHasDefault := False;

  // clear the value of the field upon creation
  ClearValue;
end;

constructor TfoDBTableField.Create(aOwnerTable: TfoDBTable; aValue: T; aFieldName: String);
begin
  // call create in TInterfacedPersistent
  inherited Create;

  // assign the parsed parameters to the local variables
  fOwnerTable := aOwnerTable;
  fValue := aValue;
  fFieldName := aFieldName;

  // set up the default flags for the database field type
  fIsAssigned := True;
  fIsChanged := False;
  fIsNull := False;
  fHasDefault := False;
  fIsIndexed := False;
  fIsPrimaryKey := False;
  fIsForeignKey := False;
end;

destructor TfoDBTableField.Destroy;
begin
  // call destroy in TInterfacedPersistent
  inherited Destroy;
end;

function TfoDBTableField.GetValue: T;
begin
  // just return the field value
  Result := fValue;
end;

procedure TfoDBTableField.SetValue(aValue: T);
begin
  // if the value that is assigned, is not the same as the value that is allready assigned
  // and this field is not set to have the value NULL
  if not ValueEquals(aValue) and (not fIsNull) then
  begin
    // this field value has now been changed
    fIsChanged := True;
    // let the owner table learn that the field was changed
    OwnerTable.ObjectStatus.IsChanged := True;
  end;

  // the field value is now no longer NULL and it is assigned
  fIsNull := False;
  fIsAssigned := True;

  // set the local generic value variable
  fValue := aValue;
end;

function TfoDBTableField.GetFieldName: String;
begin
  // just return the field name of this field
  Result := fFieldName;
end;

procedure TfoDBTableField.SetFieldName(aFieldName: String);
begin
  // assign a new field name for this field
  fFieldName := aFieldName;
end;

function TfoDBTableField.GetIsNull: Boolean;
begin
  // return whether this field value 'is set to null'
  Result := fIsNull;
end;

procedure TfoDBTableField.SetIsNull(aIsNull: Boolean);
begin
  if fIsNull <> aIsNull then
  begin
    // record that this fields value has now been changed
    fIsChanged := True;

    // let the owner table learn that the field was changed
    fOwnerTable.ObjectStatus.IsChanged := True;
  end;

  // if this field now has a value different from NULL, set that the field
  // value is now assigned
  if not aIsNull then
    fIsAssigned := True;

  // finally assign the new aIsNull value
  fIsNull := aIsNull;
end;

function TfoDBTableField.GetIsAssigned: Boolean;
begin
  // return whether this field's value is assigned to something or not
  Result := fIsAssigned;
end;

procedure TfoDBTableField.SetIsAssigned(aIsAssigned: Boolean);
begin
  // if the field's assigned indicator is currently differently set than
  // what is passed, then record that the field has now changed
  if fIsAssigned <> aIsAssigned then
  begin
    // record that the local field was changed
    fIsChanged := True;

    // let the owner table learn that the field was changed
    fOwnerTable.ObjectStatus.IsChanged := True;
  end;

  // if this field is no longer assigned to it's value, then it is effectively
  // NULL
  if not aIsAssigned then
    fIsNull := True;

  // finally set the new passed IsAssigned value
  fIsAssigned := aIsAssigned;
end;

function TfoDBTableField.GetIsChanged: Boolean;
begin
  // return whether the value of this field has been changed (since created or loaded, or saved)
  Result := fIsChanged;
end;

procedure TfoDBTableField.SetIsChanged(aIsChanged: Boolean);
begin
  // set whether ths value of this field has been changed
  fIsChanged := aIsChanged;

  if fIsChanged then
    OwnerTable.ObjectStatus.IsChanged := True;
end;

function TfoDBTableField.GetIsIndexed: Boolean;
begin
  // return whether this is an indexed field
  Result := fIsIndexed;
end;

procedure TfoDBTableField.SetIsIndexed(aIsIndexed: Boolean);
begin
  // set whether this field is an indexed field
  fIsIndexed := aIsIndexed;
end;

function TfoDBTableField.GetIsForeignKey: Boolean;
begin
  Result := fIsForeignKey;
end;

procedure TfoDBTableField.SetIsForeignKey(aIsForeignKey: Boolean);
begin
  fIsForeignKey := aIsForeignKey;
end;

function TfoDBTableField.GetIsPrimaryKey: Boolean;
begin
  Result := fIsPrimaryKey;
end;

procedure TfoDBTableField.SetIsPrimaryKey(aIsPrimaryKey: Boolean);
begin
  fIsPrimaryKey := AIsPrimaryKey;
end;

function TfoDBTableField.GetHasDefault: Boolean;
begin
  Result := fHasDefault;
end;

procedure TfoDBTableField.SetHasDefault(aHasDefault: Boolean);
begin
  fHasDefault := aHasDefault;
end;

function TfoDBTableField.GetOwnerTable: TfoDBTable;
begin
  Result := fOwnerTable;
end;

procedure TfoDBTableField.SetOwnerTable(aOwnerTable: TfoDBTable);
begin
  fOwnerTable := aOwnerTable;
end;

procedure TfoDBTableField.ClearValue;
begin
  if not fIsNull then
  begin
    IsChanged := True;
    fIsNull := True;
   end;

  fIsAssigned := False;
end;

function TfoDBTableField.ToSql: String;
begin
  // should have been abstract, but seem to get a 'unsatisfied forward declaration' error, even though the inheriting class implements it
  Result := '';
end;

function TfoDBTableField.ToXML: String;
begin
  // should have been abstract, but seem to get a 'unsatisfied forward declaration' error, even though the inheriting class implements it
  Result := '';
end;

function TfoDBTableField.AsString: String;
begin
  // should have been abstract, but seem to get a 'unsatisfied forward declaration' error, even though the inheriting class implements it
  Result := '';
end;

function TfoDBTableField.ValueEquals(aValue: T): Boolean;
begin
  // don't seem to be able to make a 'ValueEquals(aField: TfoDBTableField)' function
  // so have to make due with this. if local instance value is null then not equal
  // otherwise, compare the values and return
  // hmm, change of mind. the null checking should be pushed outside the responsibility
  // of this object, since it is not possible to implement here.
  Result := aValue = fValue;
end;

{ TfoDBTable }

constructor TfoDBTable.Create(aConnection: TSQLConnector; aMutex: TCriticalSection);
begin
  inherited Create;

  fConnection := aConnection;
  fMutex := aMutex;

  fObjectStatus := TfoDBObjectStatus.Create;
  fIsDestroying := False;

  fTableInformation := TfoDBTableInformation.Create;

  // is this really nessecary?
  {  fTableInfo.TableObject := Self; }
  fFieldList := TfoDBTableFieldList.Create;

end;

destructor TfoDBTable.Destroy;
begin
  if Assigned(fObjectStatus) then
    fObjectStatus.Free;

  if Assigned(fTableInformation) then
    fTableInformation.Free;

  inherited Destroy;
end;

function TfoDBTable.GetConnection: TSQLConnector;
begin
  // return the connector object for this table object
  Result := fConnection;
end;

procedure TfoDBTable.SetConnection(aConnection: TSQLConnector);
begin
  // set the connector object for this table object
  fConnection := aConnection;
end;

function TfoDBTable.GetFieldList: TfoDBTableFieldList;
begin
  // return the list of fields in this table
  Result := fFieldList;
end;

procedure TfoDBTable.SetFieldList(aFieldList: TfoDBTableFieldList);
begin
  // set the field list for this instance
  fFieldList := aFieldList;
end;

procedure TfoDBTable.SetTableInformation(aTableInformation: TfoDBTableInformation);
begin
  // set the local table information object to the table information object passed
  fTableInformation := aTableInformation;
end;

function TfoDBTable.GetTableInformation: TfoDBTableInformation;
begin
  // return the table information object, holding information about the table implemented in the sub class
  Result := fTableInformation;
end;

function TfoDBTable.GetMutex: TCriticalSection;
begin
  // return the lock object, the mutex
  Result := fMutex;
end;

procedure TfoDBTable.SetMutex(aMutex: TCriticalSection);
begin
  // set the lock object, the mutex
  fMutex := AMutex;
end;

function TfoDBTable.GetObjectStatus: TfoDBObjectStatus;
begin
  // return the status object, holding the status for the instance of the sub class of this class
  Result := fObjectStatus;
end;

procedure TfoDBTable.SetObjectStatus(aObjectStatus: TfoDBObjectStatus);
begin
  // set the object status for this instances
  fObjectStatus := aObjectStatus;
end;


function TfoDBTable.GetIsDestroying: Boolean;
begin
  // return the destroying state of this object, used to avoid circular memory freeing
  Result := fIsDestroying;
end;

procedure TfoDBTable.SetIsDestroying(AIsDestroying: Boolean);
begin
  // set the 'is destroying' state of this instance
  fIsDestroying := AIsDestroying;
end;

{ TfoDBObjectStatus }

constructor TfoDBObjectStatus.Create;
begin
  inherited Create;

  fCreatedTime := Now;
  fIsNew := True;
  fIsLoaded := False;
  fIsChanged := False;
  fIsDeleted := False;
  fSavedTime := 0;
  fLoadedTime := 0;
  fChangedTime := 0;
end;

destructor TfoDBObjectStatus.Destroy;
begin
  inherited Destroy;
end;

function TfoDBObjectStatus.GetIsNew: Boolean;
begin
  Result := fIsNew;
end;

procedure TfoDBObjectStatus.SetIsNew(aIsNew: Boolean);
begin
  fIsNew := aIsNew;
end;

function TfoDBObjectStatus.GetIsLoaded: Boolean;
begin
  Result := fIsLoaded;
end;

procedure TfoDBObjectStatus.SetIsLoaded(aIsLoaded: Boolean);
begin
  // set the local object IsLoaded value to the parameter
  fIsLoaded := aIsLoaded;

  // if this object is now loaded, set the LoadedTime to now, otherwise set it to 0
  if fIsLoaded then
    fLoadedTime := Now
  else
    fLoadedTime := 0;
end;

function TfoDBObjectStatus.GetIsChanged: Boolean;
begin
  Result := fIsChanged;
end;

procedure TfoDBObjectStatus.SetIsChanged(aIsChanged: Boolean);
begin
  // set the local object IsChanged value to the parameter
  fIsChanged := aIsChanged;

  // if this object is now changed set the ChangedTime to now, otherwise set it to 0
  if fIsChanged then
    fChangedTime := Now
  else
    fChangedTime := 0;
end;

function TfoDBObjectStatus.GetIsDeleted: Boolean;
begin
  Result := fIsDeleted;
end;

procedure TfoDBObjectStatus.SetIsDeleted(aIsDeleted: Boolean);
begin
  fIsDeleted := aIsDeleted;

  if fIsDeleted then
    fDeletedTime := Now
  else
    fDeletedTime := 0;
end;

function TfoDBObjectStatus.GetCreatedTime: TDateTime;
begin
  Result := fCreatedTime;
end;

procedure TfoDBObjectStatus.SetCreatedTime(aCreatedTime: TDateTime);
begin
  fCreatedTime := aCreatedTime;
end;

function TfoDBObjectStatus.GetLoadedTime: TDateTime;
begin
  Result := fLoadedTime;
end;

procedure TfoDBObjectStatus.SetLoadedTime(aLoadedTime: TDateTime);
begin
  fLoadedTime := aLoadedTime;
end;

function TfoDBObjectStatus.GetChangedTime: TDateTime;
begin
  Result := fChangedTime;
end;

procedure TfoDBObjectStatus.SetChangedTime(aChangedTime: TDateTime);
begin
  fChangedTime := aChangedTime;
end;

function TfoDBObjectStatus.GetSavedTime: TDateTime;
begin
  Result := fSavedTime;
end;

procedure TfoDBObjectStatus.SetSavedTime(aSavedTime: TDateTime);
begin
  fSavedTime := aSavedTime;
end;

function TfoDBObjectStatus.GetDeletedTime: TDateTime;
begin
  Result := fDeletedTime;
end;

procedure TfoDBObjectStatus.SetDeletedTime(aDeletedTime: TDateTime);
begin
  fDeletedTime := aDeletedTime;
end;

end.

